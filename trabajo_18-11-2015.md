# Trabajo 18-11-2015

## ToDo

* Definir de forma clara y concisa la responsabilidad de cada objeto
* Ver esquema de dispatching vs aislamiento

## Dispatching vs. Isolation

Tenemos que en los cuatro objetos principales (Extractor, Getter, Builder e Injector) la salida de uno consiste en la entrada del siguiente. Esto nos permite encarar la situación de dos formas:

* Cada objeto se ocupa de invocar al siguiente enviándole los resultados de su operatoria, dejando en el *main* (Augmentation) sólo la llamada al primer objeto (Extractor).
* Cada objeto recibe una entrada, la procesa, y retorna una salida. Así, el *main* (Augmentation) se encargaría de tomar la salida de cada objeto y enviarla al siguiente.

En principio pensamos que la segunda sería una forma más limpia de encarar el problema, ya que quedaría bien definida la responsabilidad de cada objeto, y además estos resultarían completamente desacoplados.

Luego vimos que este enfoque quitaría concurrencia, ya que al manipular las conexiones desde el *main*, la comunicación con cada objeto sería sincrónica: por cada elemento retornado por el Extractor, se invocaría a un Getter, luego a un Builder y por último a un Injector, debiendo completarse toda la secuencia de un elemento antes de continuar al siguiente.

Después nos dimos cuenta de que, en realidad, en el primer enfoque no hay asincronismo. En nuestro pensamiento, el Extractor obtenía N elementos de su Selector, y para cada uno aplicaba una función y *lanzaba* un Getter, que hacía lo que le correspondía e interactuaba con un Builder; y todo esto se llevaba a cabo de forma asincrónica, de forma tal que los N Getters comenzaban a trabajar concurrentemente. Estaría bueno hacerlo así, pero no sabemos cómo, así que por el momento este enfoque también sería sincrónico.

Cuestión, decidimos tomar el camino de gestionar el proceso desde el *main* (Augmentation), retornando cada objeto el resultado de sus operaciones en vez de invocar al siguiente objeto.

## Definición de responsabilidades

### Extractor
